log4j简介：CekiGülcü，2002年3月

版权所有©2000-2002 Apache Software Foundation。版权所有。
该软件根据Apache软件许可证2.0版的条款发布，其副本已包含在log4j发行版附带的LICENSE文件中。
本文档基于2000年11月版JavaWorld上发表的文章“Log4j提供对日志记录的控制”。
但是，本文包含更详细和最新的信息。
目前的简短手册也借用了同一作者的“完整的log4j手册”中的一些文本（真真的）。

摘要

本文档描述了log4j API、其独特的功能和设计原理。
Log4j是一个基于许多作者工作的开源项目。
它允许开发人员控制以任意粒度输出哪些日志语句。
它在运行时使用外部配置文件完全可配置。
最重要的是，log4j具有温和的学习曲线。
注意：从用户反馈来看，它也很容易上瘾。

引入/介绍
几乎每个大型应用程序都包含自己的日志记录或跟踪API。
根据这条规则，E.U.SEMPER项目决定编写自己的跟踪API,这是在1996年初。
经过无数次的增强、几个特殊的阶段以及一些API进化所需要的工作，它已经发展成为log4j————这是一个流行的Java日志包。
该软件包是在Apache软件许可证下发布的，这是一个由开源计划认证的完全开源的许可证。
最新的log4j版本，包括完整源代码，类文件和文档，可以在http://logging.apache.org/log4j/找到。
顺便说一句，log4j已被移植到C，C ++，C＃，Perl，Python，Ruby和Eiffel语言。

将日志语句插入代码是一种用于调试它的低技术方法。
它也可能是唯一的方法，因为调试器并不总是可用或适用。
而且对于多线程应用程序和分布式应用程序，通常就是这种情况（at large）。

经验表明，日志记录是开发周期的重要组成部分。
它提供了几个优点。
  1 它提供了有关应用程序运行的精确上下文。
  2 一旦插入到代码中，日志输出的生成就不需要人为干预。
  3 此外，日志输出可以保存在持久性介质中以便稍后进行研究。
  4 除了在开发周期中使用之外，还可以将足够丰富的日志包视为审计工具。
正如Brian W. Kernighan和Rob Pike在他们出色的书“编程的实践”中所说的那样:
  ```
    作为个人选择，我们倾向于不使用调试器堆栈跟踪或变量或两个变量的值。
    一个原因是它很容易迷失在复杂数据结构与控制流的细节中;
    我们发现，通读整个程序是一种低效的方式，比起更努力地思考并在关键的地方添加输出语句和自我检查的代码。
    比起浏览又没呈现的数据语句，点击每一个语句其实会更耗时；
    比起单步执行关键部分的代码（即使我们知道它在什么地方），只需要花费极少的时间去决定放置打印语句的位置。
    更重要的是，调试语句与程序保持一致;调试会话是暂时的。
  ```
  
日志确实有其缺点。它可能会减慢应用程序的速度。
如果过于冗长，则会导致“滚动失明”。
为了缓解这些问题，log4j设计为可靠，快速和可扩展。
由于日志记录很少是应用程序的主要关注点，因此log4j API易于理解和使用。
  
===
日志器，附加器和布局

Log4j有三个主要组件：记录器，追加器和布局。
这三种类型的组件协同工作，使开发人员能够根据“消息类型”和“级别”来记录消息，
并在运行时控制这些“消息的格式”以及“报告的位置”。[so many flexiblity]

记录器层次结构
---
任何日志API优于普通System.out.println的首要优势在于————它能够禁用某些日志语句，同时允许其他人不受阻碍地打印。
此功能假定日志记录空间（aka,所有可能的日志记录语句的空间）是根据“开发人员选择的某些条件”来进行分类的。
这个观察使我们之前选择了category作为一揽子计划的核心。
但是，自log4j 1.2版以来，Logger类已经取代了Category类。
对于熟悉早期版本的log4j的人来说，Logger类可以被简单地视为Category类的别名。
  
记录器是命名实体。
记录器名称区分大小写，它们遵循分层命名规则：
  命名层次结构
  如果“记录器的名称”后跟一个点就成为了“后代记录器名称的前缀”，则称记录器是另一个记录器的祖先。
  如果记录器本身与后代记录器之间没有其他代，则称记录器是子记录器的父节点。

例如，名为“com.foo”的记录器是名为“com.foo.Bar”的记录器的父级。
类似地，“java”是“java.util”的父级和“java.util.Vector”的祖先————大多数开发人员都应该熟悉这种命名方案。
“根记录器”位于记录器层次结构的顶部。
    但它与众不同：
    1 它总是存在的；
    2 它无法通过名称检索。   
调用类静态Logger.getRootLogger方法检索它（根记录器）。
而所有其他记录器都使用类静态Logger.getLogger方法进行实例化和检索————此方法将所需记录器的名称作为参数。
下面列出了Logger类中的一些基本方法：
···
  package org.apache.log4j;

  public class Logger {

    // Creation & retrieval methods:
    public static Logger getRootLogger();
    public static Logger getLogger(String name);

    // printing methods:
    public void trace(Object message);
    public void debug(Object message);
    public void info(Object message);
    public void warn(Object message);
    public void error(Object message);
    public void fatal(Object message);

    // generic printing method:
    public void log(Level l, Object message);
}
···
可以为记录器分配级别。可能的级别集合如下：
  跟踪、
  DEBUG、
  信息、
  警告、
  错误、
  致命
这些级别在org.apache.log4j.Level类中定义。  
虽然我们不鼓励您这样做，但您可以通过对Level类进行子类化来定义自己的级别。稍后将解释一个更好的方法。

级别继承
  给定记录器C的继承级别等于“记录器层次结构”中的第一个非空级别，
  从“C”开始并在层次结构中向上朝向“根记录器”继续。
  
为确保所有记录器最终都能继承一个级别，根记录器始终具有指定的级别。

下面是四个表，其中包含各种已分配的级别值以及根据上述规则生成的继承级别。
  this is non-memory list
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
